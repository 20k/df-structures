(in-package :work)

(defun ctor-addresses (address size)
  (with-bytes-for-ref (vector offset *memory* size address)
    (loop for i from 0 below size by 4
       for val = (parse-int vector (+ offset i) 4)
       unless (member val '(0 #xFFFFFFFF))
       collect val)))

(defun disasm-at-addr (address size)
  (with-bytes-for-ref (vector offset *memory* size address)
    (dolist (cmd (disassemble-all vector :start offset :end (+ offset size)
                                  :base-address address :errorp nil))
      (when cmd
        (format t "~10X: ~A~%" (x86-instruction-address cmd) (x86-instruction-text cmd))))))

(defun get-function-addrs (name)
  (mapcar #'start-address-of
          (remove-if-not (lambda (x &aux (org (origin-of x)))
                           (or (typep org 'executable-region-plt-entry)
                               (typep org 'executable-region-function)))
                         (find-regions-by-name (executable-of *process*) name))))

(defun describe-function (addr)
  (format nil "0x~X~@[ [~A]~]" addr
          (awhen (find-region-by-address (executable-of *process*) addr)
            (symbol-name-of it))))

(defun is-stack-var? (arg)
  (when (and (typep arg 'x86-argument-memory)
             (eq (x86-argument-memory-base-reg arg) :esp)
             (null (x86-argument-memory-index-reg arg)))
    (x86-argument-memory-displacement arg)))

(defun collect-ctor-globals (address)
  (with-bytes-for-ref (vector offset *memory* 16 address)
    (let ((globals nil)
          (dtor-addr nil)
          (obj-addr nil)
          (ctors nil)
          (atexit-addrs (get-function-addrs "__cxa_atexit")))
      (labels ((is-atexit? (addr)
                 (member addr atexit-addrs)))
        (disassemble-iter (cmd vector :start offset :base-address address :errorp nil)
          (case (x86-instruction-mnemonic cmd)
            (:ret (return))
            (:call (let ((addr (x86-instruction-addr-value cmd)))
                     (if (is-atexit? addr)
                         (let ((cmstr (format nil "~{ctor ~A; ~}dtor ~A"
                                              (mapcar #'describe-function ctors)
                                              (describe-function dtor-addr))))
                           (when globals
                             (let ((size (- obj-addr (offset-of (first globals)))))
                               (when (> size 0)
                                 (setf (size-of (first globals)) size))))
                           (push (make-instance 'global-object
                                                :name (cl-linux-debug.data-info::get-$-field
                                                       (format nil "obj_~X" obj-addr))
                                                :offset obj-addr
                                                :comment (make-instance 'comment :content cmstr))
                                 globals)
                           (setf dtor-addr nil obj-addr nil ctors nil))
                         (push addr ctors))))
            (:mov (when (typep (x86-instruction-argument2 cmd) 'x86-argument-constant)
                    (case (is-stack-var? (x86-instruction-argument1 cmd))
                      (0 (setf dtor-addr (x86-instruction-immediate cmd)))
                      (4 (setf obj-addr (x86-instruction-immediate cmd))))))))
        (nreverse globals)))))

(defun list-globals/linux ()
  (let ((section (find-section-by-name (main-image-of (executable-of *process*)) ".ctors")))
    (loop for addr in (ctor-addresses (start-address-of section) (length-of section))
       nconc (collect-ctor-globals addr))))

(defun scan-linux-destructor (address)
  (let* ((region (find-region-by-address (executable-of *process*) address))
         (vector (data-bytes-of region))
         (offset (start-offset-of region))
         (unwinds (region-unwind-table (origin-of region))))
    (let ((reg-state nil)
          (stack-top nil)
          (del-one (get-function-addrs "_ZdlPv"))
          (del-arr (get-function-addrs "_ZdaPv"))
          (del-str (get-function-addrs "_ZNSsD1Ev")))
      (labels ((emit-call (cmd name)
                 (format t "~X: call ~A (~A)~%"
                         (x86-instruction-address cmd)
                         name stack-top))
               (get-reg (reg)
                 (if reg
                     (or (assoc-value reg-state reg) "?")
                     nil)))
        (disassemble-iter (cmd vector
                               :start offset :base-address (start-address-of region)
                               :end (aif (length-of region) (+ offset it))
                               :errorp nil)
          (case (x86-instruction-mnemonic cmd)
            (:ret (return))
            (:jmp
             (let ((addr (x86-instruction-addr-value cmd)))
               (unless (<= 0 (- addr (start-address-of region))
                           (or (length-of region) 16384))
                 (emit-call cmd (describe-function addr))
                 (return))))
            (:call
             (let ((addr (x86-instruction-addr-value cmd)))
               (cond ((member addr del-one)
                      (emit-call cmd "delete"))
                     ((member addr del-arr)
                      (emit-call cmd "delete[]"))
                     ((member addr del-str)
                      (emit-call cmd "~string"))
                     (t
                      (emit-call cmd (describe-function addr))))))
            ((:mov :lea)
             (let ((arg1 (x86-instruction-argument1 cmd))
                   (arg2 (x86-instruction-argument2 cmd)))
               (let ((val (acond ((is-stack-var? arg2)
                                  (let ((unwind (lookup-chunk unwinds (x86-instruction-address cmd))))
                                    (when (and unwind (= it (unwind-state-cfa unwind)))
                                      "object")))
                                 ((typep arg2 'x86-argument-register)
                                  (get-reg (x86-argument-register-id arg2)))
                                 ((typep arg2 'x86-argument-memory)
                                  (let ((val
                                         (if (and (null (x86-argument-memory-index-reg arg2))
                                                  (= (x86-argument-memory-displacement arg2) 0))
                                             (get-reg (x86-argument-memory-base-reg arg2))
                                             (format nil "~@[~A+~]~{~A*~A+~}0x~X"
                                                     (get-reg (x86-argument-memory-base-reg arg2))
                                                     (awhen (get-reg (x86-argument-memory-index-reg arg2))
                                                       (list it (x86-argument-memory-scale arg2)))
                                                     (x86-argument-memory-displacement arg2)))))
                                    (if (eq (x86-instruction-mnemonic cmd) :lea)
                                        val
                                        (concatenate 'string "[" val "]"))))
                                 ((typep arg2 'x86-argument-constant)
                                  (format nil "0x~X" (x86-instruction-immediate cmd))))))
                 (acond ((is-stack-var? arg1)
                         (when (= it 0)
                           (setf stack-top val)))
                        ((typep arg1 'x86-argument-register)
                         (setf (assoc-value reg-state (x86-argument-register-id arg1)) val))))))))))))
